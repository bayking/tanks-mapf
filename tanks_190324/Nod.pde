/*
* Mustafa Bay
* Maximilian TÃ¶rnqvist
* Fredrik Hammar
*/
import java.util.*;
import java.util.stream.Collectors;

/**
 * Artificial Intelligence A Modern Approach (3rd Edition): Figure 3.10, page
 * 79.<br>
 *
 * Figure 3.10 Nodes are the data structures from which the search tree is
 * constructed. Each has a parent, a state, and various bookkeeping fields.
 * Arrows point from child to parent.<br>
 * <br>
 * Search algorithms require a data structure to keep track of the search tree
 * that is being constructed. For each node n of the tree, we have a structure
 * that contains four components:
 * <ul>
 * <li>n.STATE: the state in the state space to which the node corresponds;</li>
 * <li>n.PARENT: the node in the search tree that generated this node;</li>
 * <li>n.ACTION: the action that was applied to the parent to generate the node;
 * </li>
 * <li>n.PATH-COST: the cost, traditionally denoted by g(n), of the path from
 * the initial state to the node, as indicated by the parent pointers.</li>
 * </ul>
 *
 * @param <S> The type used to represent states
 * @param <A> The type of the actions to be used to navigate through the state space
 *
 * @author Ravi Mohan
 * @author Ciaran O'Reilly
 * @author Mike Stampone
 * @author Ruediger Lunde
 * @author Mustafa Bay
 */

public class Nod<S, A> {
  
  // n.STATE: the state in the state space to which the node corresponds;
  private final S state;
  
  // n.PARENT: the node in the search tree that generated this node;
  private final Nod<S, A> parent;
  
  // n.ACTION: the action that was applied to the parent to generate the node;
  private final A action;
  
  // n.PATH-COST: the cost, traditionally denoted by g(n), of the path from
  // the initial state to the node, as indicated by the parent pointers.
  private float pathCost;
  
  // Step cost
  private final int step;
  
    /**
     * Constructs a root node for the specified state.
     *
     * @param state
     *            the state in the state space to which the node corresponds.
     */
    public Nod(S state) {
       this.state = state;
       this.parent = null;
       this.action = null;
       this.pathCost = 0.0;
       this.step = 0;
    }
  
  /**
     * Constructs a node with the specified state, parent, action, and path
     * cost.
     *
     * @param state
     *            the state in the state space to which the node corresponds.
     * @param parent
     *            the node in the search tree that generated the node.
     * @param action
     *            the action that was applied to the parent to generate the
     *            node.
     * @param pathCost
     *            full pathCost from the root node to here, typically
     *            the root's path costs plus the step costs for executing
     *            the the specified action.
     */
    public Nod(S state, Nod parent, A action, float pathCost, int step) {
        this.state = state;
        this.parent = parent;
        this.action = action;
        this.pathCost = pathCost;
        this.step = step;
    }
    
    /**
     * Returns the state in the state space to which the node corresponds.
     *
     * @return the state in the state space to which the node corresponds.
     */
    public S getState() {
        return state;
    }

    /**
     * Returns this node's parent node, from which this node was generated.
     *
     * @return the node's parenet node, from which this node was generated.
     */
    public Nod<S,A> getParent() {
        return parent;
    }

    /**
     * Returns the action that was applied to the parent to generate the node.
     *
     * @return the action that was applied to the parent to generate the node.
     */
    public A getAction() {
        return action;
    }

    /**
     * Returns the cost of the path from the initial state to this node as
     * indicated by the parent pointers.
     *
     * @return the cost of the path from the initial state to this node as
     *         indicated by the parent pointers.
     */
    public float getPathCost() {
        return pathCost;
    }

    /**
     * Returns <code>true</code> if the node has no parent.
     *
     * @return <code>true</code> if the node has no parent.
     */
    public boolean isRootNode() {
        return parent == null;
    }

    /**
     * Returns all the nodes reachable in one step from this node
     *
     * @return the set of nodes reachable in one step from this node
     */
    public HashSet<Nod<S, A>> expand(Problem problem) {
        HashSet<Nod<S, A>> nodes = new HashSet<>();
        for (Object a : problem.getActions(getState())) {
            nodes.add(childNode(problem, (A) a));
        }
        return nodes;
    }

    /**
     * Returns the next node generated by action on this
     *
     * @return the next node generated by action on this
     */
    public Nod childNode(Problem problem, A action) {
        S nextState = (S) problem.getResult(getState(), action);
        Nod<S, A> nextNode = new Nod(nextState, this, action, problem.getPathCost(this.getPathCost(), getState(), action, nextState), step+1);
        return nextNode;
    }

    /**
     * Returns a queue of nodes forming the path from the root to this node
     *
     * @return a queue of nodes forming the path from the root to this node
     */

    public Queue<Nod> path() {
        List<Nod> pathBack = new LinkedList<>();
        Nod node = this;

        while (!node.isRootNode()) {
            pathBack.add(node);
            node = node.parent;
        }
        Collections.reverse(pathBack);
        Queue<Nod> returnPath = new LinkedList<>(pathBack);
        return returnPath;
    }

    /**
     * Returns a list with the sequence of actions to go from root to this node
     * User need to cast Object to Action
     * @return a list with the sequence of actions (Object) to go from root to this node
     */
    public List<Object> solution() {
        List<Object> solution = path()
                .stream()
                .map(Nod::getAction)
                .collect(Collectors.toList());
        return solution;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Nod))
            return false;
        Nod<S, A> node = (Nod) o;

        return Objects.equals(state, node.state);
    }
    
    @Override
    public int hashCode() {
        return Objects.hashCode(this.state);
    }

    @Override
    public String toString() {
        return "[parent=" + parent + ", action=" + action + ", state=" + getState() + ", pathCost=" + pathCost + "]";
    }
}
